---
title: Notes of cs188 Artificial Intelligence
date: 2018-06-27 08:47:04
tags:
- Predictably Irrational
- Notes
categories:
- Notes
- Computer Science
---
My notes of UC Berkeley online course [Intro to Artificial Intelligence](https://www.bilibili.com/video/av15628609/?p=5)
<!-- more -->

## Search

### Two type of search
#### Planning: sequences of actions
* The path to the goal is the important thing
* Paths have various costs, depths
* Heuristics give problem-specific guidance

#### Identification: assignments to variables
* The goal itself is important, not the path
* All paths at the same depth (for some formulations)
* CSPs are specialized for identification problems

### Uninformed and Informed Search (Planning)
* All search algorithms are the same except for fringe strategies.
* **Informed Search**: Introduced heuristic to estimate of distance to nearest goal for each state and therefore speed up search (Solve performance problem of UCS).

#### Abstraction
* A state space.
* A successor function (with actions, costs).
* A start state and a goal test.

#### Example
* Traveling in Romania (Map with weighted edge)
* Pac-man game planning
* Pancake Problem

#### Properties
* Complete: Guaranteed to find a solution if one exists?
* Optimal: Guaranteed to find the least cost path?
* Time and space complexity.

#### Depth-First Search (DFS)
* Complete if we prevent cycles
* Not optimal
* Time O(b^m)
* Space O(bm)

#### Breadth-First Search (BFS)
* Complete
* Optimal only if costs are all 1
* Time O(b^s)
* Space O(b^s)

#### Uniform Cost Search (UCS)
* Complete and optimal
* Time O(b^(C*/E))  
* Space O(b^(C*/E))
* **Problem**: Explores options in every “direction” because no information about goal location

#### Greedy Search
* Expand the node that seems closest
* **Can be wrong** because of this (not optimal)

#### A*: Combining UCS and Greedy
Uniform-cost orders by path cost, or backward cost **g(n)**. Greedy orders by goal proximity, or forward cost **h(n)**. A* Search orders by the sum: **f(n) = g(n) + h(n)**.

##### Admissibility
* Inadmissible (pessimistic) heuristics break optimality by trapping good plans on the fringe
* Admissible (optimistic) heuristics slow down bad plans but never outweigh true costs
* A heuristic h is admissible (optimistic) if: 0 <= h(n) <= h*(n) where h*(n) is the true cost to a nearest goal.

##### Consistency
Heuristic “arc” cost ≤ actual cost for each arc: h(A) – h(C) ≤ cost(A to C)

##### Heuristic design
A* is **optimal** with admissible/consistent heuristics. In general, most natural admissible heuristics tend to be consistent, especially if from relaxed problems so often use relaxed problems.

##### Comparison
![](https://ws1.sinaimg.cn/large/006tNc79gy1fsq1quaa3vj31a20e2wg6.jpg)

### Constraint Satisfaction Problems (Identification)

#### Abstraction
* A special subset of search problems
* State is defined by variables Xi  with values from a domain D (sometimes D depends on i)
* Goal test is a set of constraints specifying allowable combinations of values for subsets of variables

#### Example
* Map Coloring
* N-Queens
* Cryptarithmetic
* Sudoku

#### Backtracking Search
Backtracking search is the basic uninformed algorithm for solving CSPs

* **idea 1: One variable at a time**: Variable assignments are commutative, so only need to consider assignments to a single variable at each step

* **Idea 2: Check constraints as you go**: Consider only values which do not conflict previous assignments. (Might have to do some computation to check the constraints “Incremental goal test”)

#### Improving Backtracking

##### Filtering
Detect inevitable failure early: Keep track of domains for unassigned variables and cross off bad options.

###### Forward Checking
Cross off values that violate a constraint when added to the existing assignment.

**Disadvantage**: doesn't provide early detection for all failures.

###### Constraint Propagation
Forward checking propagates information from assigned to unassigned variables, but doesn't provide early detection for all failures.

So introduce **Arc consistent**: An arc X->Y is consistent iff for every x in the tail there is some y in the head which could be assigned without violating a constraint.

A simple form of propagation makes sure all arcs are consistent.

**Disadvantage**: Running slow and can have no solutions left.
